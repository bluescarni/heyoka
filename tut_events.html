

<!DOCTYPE html>


<html lang="en" data-content_root="" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

    <title>Event detection &#8212; heyoka 4.0.0 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="_static/styles/bootstrap.css?digest=5b4479735964841361fd" rel="stylesheet" />
<link href="_static/styles/pydata-sphinx-theme.css?digest=5b4479735964841361fd" rel="stylesheet" />

  
  <link href="_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=5b4479735964841361fd" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/bootstrap.js?digest=5b4479735964841361fd" />
<link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd" />
  <script src="_static/vendor/fontawesome/6.1.2/js/all.min.js?digest=5b4479735964841361fd"></script>

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'tut_events';</script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Advanced tutorials" href="advanced_tutorials.html" />
    <link rel="prev" title="Dense &amp; continuous output" href="tut_d_output.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <div id="pst-scroll-pixel-helper"></div>

  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>

  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  

<a class="navbar-brand logo" href="index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="_static/white_logo.png" class="logo__image only-light" alt="heyoka 4.0.0 documentation - Home"/>
    <script>document.write(`<img src="_static/white_logo.png" class="logo__image only-dark" alt="heyoka 4.0.0 documentation - Home"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="basic_tutorials.html">Basic tutorials</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="tut_taylor_method.html">Taylor’s method</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_expression_system.html">The expression system</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_adaptive.html">The adaptive integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_adaptive_custom.html">Customising the adaptive integrator</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_param.html">Runtime parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_nonauto.html">Non-autonomous systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_d_output.html">Dense &amp; continuous output</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Event detection</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="advanced_tutorials.html">Advanced tutorials</a><input class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="tut_batch_mode.html">Batch mode</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_extended_precision.html">Computations in extended precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_arbitrary_precision.html">Computations in arbitrary precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_single_precision.html">Computations in single precision</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_s11n.html">Serialisation</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_ensemble.html">Ensemble propagations</a></li>
<li class="toctree-l2"><a class="reference internal" href="tut_parallel_mode.html">Parallel mode</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="api_reference.html">API Reference</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="definitions.html">Macros and definitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="namespaces.html">Namespaces</a></li>
<li class="toctree-l2"><a class="reference internal" href="kwargs.html">Keyword arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="exceptions.html">Exceptions</a></li>
<li class="toctree-l2 has-children"><a class="reference internal" href="expression_system.html">Expression system</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l3"><a class="reference internal" href="variable.html">Variables</a></li>
<li class="toctree-l3"><a class="reference internal" href="number.html">Numerical constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="param.html">Runtime parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="func.html">Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="expression.html">Expressions</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="benchmarks.html">Benchmarks</a></li>
<li class="toctree-l1"><a class="reference internal" href="ad_notes.html">Notes on automatic differentiation</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="breaking_changes.html">Breaking changes</a></li>
<li class="toctree-l1"><a class="reference internal" href="known_issues.html">Known issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgement.html">Acknowledgement</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">





<div class="dropdown dropdown-source-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Source repositories">
    <i class="fab fa-github"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="https://github.com/bluescarni/heyoka" target="_blank"
   class="btn btn-sm btn-source-repository-button dropdown-item"
   title="Source repository"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="btn__text-container">Repository</span>
</a>
</li>
      
      
      
      
      <li><a href="https://github.com/bluescarni/heyoka/issues/new?title=Issue%20on%20page%20%2Ftut_events.html&body=Your%20issue%20content%20here." target="_blank"
   class="btn btn-sm btn-source-issues-button dropdown-item"
   title="Open an issue"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="btn__text-container">Open issue</span>
</a>
</li>
      
  </ul>
</div>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="_sources/tut_events.rst" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.rst</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script>


<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Event detection</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#non-terminal-events">Non-terminal events</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#event-direction">Event direction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-events">Multiple events</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#terminal-events">Terminal events</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cooldown">Cooldown</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#limitations-and-caveats">Limitations and caveats</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#badly-conditioned-event-equations">Badly-conditioned event equations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#event-equations-and-timestepping">Event equations and timestepping</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#full-code-listing">Full code listing</a></li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section id="event-detection">
<span id="tut-events"></span><h1>Event detection<a class="headerlink" href="#event-detection" title="Permalink to this heading">#</a></h1>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.6.0.</span></p>
</div>
<p>When integrating systems of ODEs, the need often arises to detect the occurrence of specific
conditions (or <em>events</em>) in the state of the system. Many real systems, for instance, are described by equations
that change discontinuously in response to particular conditions
(e.g., a spacecraft entering the cone of shadow of a planet,
or a thermostat switching on once the temperature reaches a certain level). In other situations,
detection of specific system states may suffice (e.g., in the computation of
<a class="reference external" href="https://en.wikipedia.org/wiki/Poincar%C3%A9_map">Poincaré sections</a>).</p>
<p>An event in a system of ODEs can be defined by an <em>event equation</em> of the form</p>
<div class="math notranslate nohighlight">
\[g\left( t, \boldsymbol{x} \left( t \right) \right) = 0,\]</div>
<p>where, as usual, <span class="math notranslate nohighlight">\(t\)</span> is the independent variable (time) and <span class="math notranslate nohighlight">\(\boldsymbol{x} \left( t \right)\)</span> the state vector of the system.
As a concrete example, the collision between two spheres of radius 1 moving in a three-dimensional space can be described
by the event equation</p>
<div class="math notranslate nohighlight">
\[\left( x_1 - x_0 \right)^2 + \left( y_1 - y_0 \right)^2 + \left( z_1 - z_0 \right)^2 - 4 = 0,\]</div>
<p>where <span class="math notranslate nohighlight">\(\left( x_0, y_0, z_0 \right)\)</span> and <span class="math notranslate nohighlight">\(\left( x_1, y_1, z_1 \right)\)</span> are the Cartesian coordinates
of the spheres’ centres.</p>
<p>heyoka features a flexible and accurate event detection framework in which the <a class="reference internal" href="tut_expression_system.html#tut-expression-system"><span class="std std-ref">expression system</span></a>
can be used to formulate arbitrary event equations. The event equations are then added to the ODE system and
integrated together with the other equations, so that, at every timestep, a Taylor series expansion of the event equations
in powers of time is available. Polynomial root finding techniques <span id="id1">[<a class="reference internal" href="bibliography.html#id9" title="George E. Collins and Alkiviadis G. Akritas. Polynomial real root isolation using Descartes' rule of signs. In Proceedings of the third ACM symposium on Symbolic and algebraic computation, 272–275. 1976.">CA76</a>]</span> are then employed
on the Taylor series of the event equations to accurately locate the time of occurrence of an event within the timestep.</p>
<p>Like many other ODE integration libraries, heyoka makes a fundamental distinction between two types of events, <em>terminal</em> and <em>non-terminal</em>.
We will begin with non-terminal events, as they are conceptually simpler.</p>
<section id="non-terminal-events">
<h2>Non-terminal events<a class="headerlink" href="#non-terminal-events" title="Permalink to this heading">#</a></h2>
<p>Non-terminal events are events that do not modify the state of an ODE system. That is, the occurrence of a non-terminal event does not
change the system’s dynamics and it does not alter the state vector of the system. A typical use of non-terminal events is to detect and log
when the system reaches a particular state of interest (e.g., flagging close encounters between celestial bodies, detecting when
a velocity or coordinate is zero, etc.).</p>
<p>As an initial example, we will turn to our good ole friend, the simple pendulum:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
x^\prime = v \\
v^\prime = -9.8 \sin x
\end{cases}.\end{split}\]</div>
<p>Our goal will be to detect when the bob reaches the point of maximum amplitude, which corresponds to the angular velocity
<span class="math notranslate nohighlight">\(v\)</span> going to zero. In other words, out (very simple) event equation is</p>
<div class="math notranslate nohighlight">
\[v = 0.\]</div>
<p>We begin, as usual, with the definition of the symbolic variables:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Create the symbolic variables x and v.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_vars</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;v&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>Next, we create a vector into which we will log the times at which <span class="math notranslate nohighlight">\(v = 0\)</span>:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Create a vector to store the times</span>
<span class="w">    </span><span class="c1">// at which v goes to zero.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">;</span>
</pre></div>
</div>
<p>We can now proceed to create a non-terminal event:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Create the event object for the detection</span>
<span class="w">    </span><span class="c1">// of &#39;v == 0&#39;.</span>
<span class="w">    </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev</span><span class="p">(</span>
<span class="w">        </span><span class="c1">// The left-hand side of the event equation</span>
<span class="w">        </span><span class="n">v</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// The callback.</span>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">zero_vel_times</span><span class="p">](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ta</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Compute the state of the system when the</span>
<span class="w">            </span><span class="c1">// event triggered and print the value of x.</span>
<span class="w">            </span><span class="n">ta</span><span class="p">.</span><span class="n">update_d_output</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Value of x when v is zero: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ta</span><span class="p">.</span><span class="n">get_d_output</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Add the event time to zero_vel_times.</span>
<span class="w">            </span><span class="n">zero_vel_times</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>
</pre></div>
</div>
<p>Non-terminal events are represented in heyoka by the <code class="docutils literal notranslate"><span class="pre">nt_event</span></code> class. Like the <a class="reference internal" href="tut_adaptive.html#tut-adaptive"><span class="std std-ref">adaptive integrator</span></a>
class, <code class="docutils literal notranslate"><span class="pre">nt_event</span></code> is parametrised over the floating-point type we want to use for  event detection
(in this case, <code class="docutils literal notranslate"><span class="pre">double</span></code>). The first mandatory argument for the construction of a non-terminal event is the left-hand
side of the event equation, which in this case is simply <span class="math notranslate nohighlight">\(v\)</span>.</p>
<p>The second mandatory construction argument is a callback function that will be invoked when the event is detected.
The callback function can be a lambda, a regular function, or a function object - the only requirement is that the
callback is a callable object with the following signature:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="p">(</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">);</span>
</pre></div>
</div>
<p>The first argument is a mutable reference to the integrator object, the second argument is the absolute time
at which the event was detected (i.e., the trigger time), and the last argument is the sign of the derivative
of the event equation at the trigger time (-1 for negative derivative, 1 for positive derivative and 0 for
zero derivative).</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>The <code class="docutils literal notranslate"><span class="pre">taylor_adaptive</span></code> object is passed as a non-const reference only so that it is possible to call
non-const functions on it (such as <code class="docutils literal notranslate"><span class="pre">update_d_output()</span></code>). Do not try to assign a new integrator object
from within the callback, as that will result in undefined behaviour.</p>
</div>
<p>Because non-terminal event detection is performed at the end of an integration step,
when the callback is invoked the state and time of the integrator object are those <strong>at the end</strong> of the integration
step in which the event was detected. Note that when integrating an ODE system with events, the <code class="docutils literal notranslate"><span class="pre">taylor_adaptive</span></code>
class ensures that the Taylor coefficients are always kept up to date (as explained in the tutorial about
<a class="reference internal" href="tut_d_output.html#tut-d-output"><span class="std std-ref">dense output</span></a>), and thus in the callback function it is always possible to use the <code class="docutils literal notranslate"><span class="pre">update_d_output()</span></code>
function to compute the dense output at any time within the last timestep that was taken.</p>
<p>In this example, we perform two actions in the callback:</p>
<ul class="simple">
<li><p>first, we compute the dense output at the event trigger time and print
the value of the <code class="docutils literal notranslate"><span class="pre">x</span></code> coordinate,</p></li>
<li><p>second, we append to <code class="docutils literal notranslate"><span class="pre">zero_vel_times</span></code> the trigger time.</p></li>
</ul>
<p>We are now ready to create our first event-detecting integrator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Create the integrator object</span>
<span class="w">    </span><span class="c1">// in double precision.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="c1">// Definition of the ODE system:</span>
<span class="w">                                      </span><span class="c1">// x&#39; = v</span>
<span class="w">                                      </span><span class="c1">// v&#39; = -9.8 * sin(x)</span>
<span class="w">                                      </span><span class="p">{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span>
<span class="w">                                      </span><span class="c1">// Initial conditions</span>
<span class="w">                                      </span><span class="c1">// for x and v.</span>
<span class="w">                                      </span><span class="p">{</span><span class="mf">-0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">},</span>
<span class="w">                                      </span><span class="c1">// Non-terminal events.</span>
<span class="w">                                      </span><span class="n">kw</span><span class="o">::</span><span class="n">nt_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ev</span><span class="p">}};</span>
</pre></div>
</div>
<p>The list of non-terminal events is passed to the constructor of the
integrator via the <code class="docutils literal notranslate"><span class="pre">kw::nt_events</span></code> keyword argument. Note how we
set up the initial conditions so that the bob is at rest at an
angle of amplitude <span class="math notranslate nohighlight">\(0.05\)</span>.</p>
<p>Let us now integrate for a few time units and observe the screen output:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Propagate for a few time units.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Value of x when v is zero: -0.05</span>
<span class="go">Value of x when v is zero: 0.05</span>
<span class="go">Value of x when v is zero: -0.05</span>
<span class="go">Value of x when v is zero: 0.05</span>
<span class="go">Value of x when v is zero: -0.05</span>
</pre></div>
</div>
<p>As expected, when the velocity of the bob goes to zero
the absolute value the <span class="math notranslate nohighlight">\(x\)</span> angle corresponds to the
initial amplitude of <span class="math notranslate nohighlight">\(0.05\)</span>.</p>
<p>Let us now print the event times:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Print the event times.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event detection time: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Event detection time: 0</span>
<span class="go">Event detection time: 1.003701787940065</span>
<span class="go">Event detection time: 2.00740357588013</span>
<span class="go">Event detection time: 3.011105363820196</span>
<span class="go">Event detection time: 4.014807151760261</span>
</pre></div>
</div>
<p>We can see how the the initial condition <span class="math notranslate nohighlight">\(v_0 = 0\)</span> immediately
and correctly triggers an event at <span class="math notranslate nohighlight">\(t = 0\)</span>. Physically, we know that the time
interval between the events must be half the period <span class="math notranslate nohighlight">\(T\)</span> of the pendulum,
which can be computed exactly via elliptic functions. With the specific
initial conditions of this example, <span class="math notranslate nohighlight">\(T = 2.0074035758801299\ldots\)</span>, and
we can see from the event times printed to screen
how the event detection system was accurate to machine precision.</p>
<section id="event-direction">
<h3>Event direction<a class="headerlink" href="#event-direction" title="Permalink to this heading">#</a></h3>
<p>By default, heyoka will detect all zeroes of the event equations regardless
of the <em>direction</em> of the zero crossing (i.e., the value of the time derivative
of the event equation at the zero). However, it is sometimes useful to trigger the detection
of an event only if its direction is positive or negative. Event direction is represented
in heyoka by the <code class="docutils literal notranslate"><span class="pre">event_direction</span></code> enum, whose values can be</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">event_direction::any</span></code> (the default),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">event_direction::positive</span></code> (derivative &gt; 0),</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">event_direction::negative</span></code> (derivative &lt; 0).</p></li>
</ul>
<p>Event direction can be specified upon construction via the <code class="docutils literal notranslate"><span class="pre">kw::direction</span></code> keyword:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Redefine ev to detect only events</span>
<span class="w">    </span><span class="c1">// in the positive direction.</span>
<span class="w">    </span><span class="n">ev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">zero_vel_times</span><span class="p">](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">time</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="c1">// Specify the direction.</span>
<span class="w">        </span><span class="n">kw</span><span class="o">::</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event_direction</span><span class="o">::</span><span class="n">positive</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Reset zero_vel_times and the integrator.</span>
<span class="w">    </span><span class="n">zero_vel_times</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">},</span><span class="w"> </span><span class="n">kw</span><span class="o">::</span><span class="n">nt_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ev</span><span class="p">}};</span>
</pre></div>
</div>
<p>In this specific case, constraining the event direction to be positive is equivalent
to detecting <span class="math notranslate nohighlight">\(v = 0\)</span> only when the pendulum reaches the maximum amplitude on the left.
Let us take a look at the event times:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Propagate for a few time units.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print the event times.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event detection time: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Event detection time: 0</span>
<span class="go">Event detection time: 2.00740357588013</span>
<span class="go">Event detection time: 4.014807151760261</span>
</pre></div>
</div>
<p>Indeed, the event now triggers only 3 times (instead of 5), and the times confirm
that the event is detected only when <span class="math notranslate nohighlight">\(v\)</span> switches from negative to positive, i.e.,
at <span class="math notranslate nohighlight">\(t=0\)</span>, <span class="math notranslate nohighlight">\(t=T\)</span> and <span class="math notranslate nohighlight">\(t=2T\)</span>.</p>
</section>
<section id="multiple-events">
<h3>Multiple events<a class="headerlink" href="#multiple-events" title="Permalink to this heading">#</a></h3>
<p>When multiple events trigger within the same timestep (or if the same event triggers
multiple times), heyoka will process the events in chronological order
(or reverse chronological order when integrating backwards in time).</p>
<p>Let us demonstrate this with another example with the simple pendulum.
We will now aim to detect two events defined by the equations:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
v = 0 \\
v^2 - 10^{-12} = 0
\end{cases}.\end{split}\]</div>
<p>In other words, we are looking to determine the time of maximum amplitude (<span class="math notranslate nohighlight">\(v = 0\)</span>) and
the time at which the absolute value of the angular velocity is small but not zero. Because
of the closeness of these events, we can expect both events to be detected during the same timestep,
with the second event triggering twice.</p>
<p>Let’s begin by defining the two events:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Define two close non-terminal events.</span>
<span class="w">    </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev0</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event 0 triggering at t=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev1</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1e-12</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event 1 triggering at t=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
</pre></div>
</div>
<p>This time the events’ callbacks just print the event time to screen, without
modifying the <code class="docutils literal notranslate"><span class="pre">zero_vel_times</span></code> list.</p>
<p>We can then reset the integrator, propagate for a few time units and check the screen output:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Reset the integrator.</span>
<span class="w">    </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">},</span><span class="w"> </span><span class="n">kw</span><span class="o">::</span><span class="n">nt_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ev0</span><span class="p">,</span><span class="w"> </span><span class="n">ev1</span><span class="p">}};</span>

<span class="w">    </span><span class="c1">// Propagate for a few time units.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Event 0 triggering at t=0</span>
<span class="go">Event 1 triggering at t=2.041666914753826e-06</span>
<span class="go">Event 1 triggering at t=1.003699746272244</span>
<span class="go">Event 0 triggering at t=1.003701787940065</span>
<span class="go">Event 1 triggering at t=1.003703829606799</span>
<span class="go">Event 1 triggering at t=2.007401534213656</span>
<span class="go">Event 0 triggering at t=2.00740357588013</span>
<span class="go">Event 1 triggering at t=2.00740561754654</span>
<span class="go">Event 1 triggering at t=3.011103322152711</span>
<span class="go">Event 0 triggering at t=3.011105363820196</span>
<span class="go">Event 1 triggering at t=3.011107405487484</span>
<span class="go">Event 1 triggering at t=4.014805110093445</span>
<span class="go">Event 0 triggering at t=4.014807151760261</span>
<span class="go">Event 1 triggering at t=4.014809193427102</span>
</pre></div>
</div>
<p>Note how the events are indeed processed in chronological order, and how the event detection system is able to
successfully recognize the second event triggering twice in close succession.</p>
</section>
</section>
<section id="terminal-events">
<h2>Terminal events<a class="headerlink" href="#terminal-events" title="Permalink to this heading">#</a></h2>
<p>The fundamental characteristic of terminal events is that, in contrast to non-terminal events,
they alter the dynamics and/or the state of the system. A typical example of a terminal event is the
<a class="reference external" href="https://en.wikipedia.org/wiki/Elastic_collision">elastic collision</a> of
two rigid bodies, which instantaneously and discontinuously changes the bodies’ velocity vectors.
Another example is the switching on of a spacecraft engine, which alters the differential
equations governing the dynamics of the spacecraft.</p>
<p>Terminal events are represented in heyoka by the <code class="docutils literal notranslate"><span class="pre">t_event</span></code> class. Similarly to
the <code class="docutils literal notranslate"><span class="pre">nt_event</span></code> class, the construction of a <code class="docutils literal notranslate"><span class="pre">t_event</span></code> requires
at the very least the expression corresponding to the left-hand side of the event equation.
A number of additional optional keyword arguments can be passed to customise the behaviour
of a terminal event:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">kw::callback</span></code>: a callback function that will be called when the event triggers. Note that,
for terminal events, the presence of a callback is optional (whereas it is mandatory for
non-terminal events);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kw::cooldown</span></code>: a floating-point value representing the cooldown time for the terminal event
(see <a class="reference internal" href="#tut-t-event-cooldown"><span class="std std-ref">below</span></a> for an explanation);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">kw::direction</span></code>: a value of the <code class="docutils literal notranslate"><span class="pre">event_direction</span></code> enum which, like for non-terminal
events, can be used to specify that the event should be detected only for a specific direction
of the zero crossing.</p></li>
</ul>
<p>It is important to understand how heyoka reacts to terminal events. At every integration timestep, heyoka
performs event detection for both terminal and non-terminal events. If one or more terminal events
are detected, heyoka will sort the detected terminal events by time and will select the first
terminal event triggering in chronological order (or reverse chronological order when integrating
backwards in time). All the other terminal events and all the non-terminal events triggering <em>after</em>
the first terminal event are discarded. heyoka then propagates the state of the system up to the
trigger time of the first terminal event, executes the callbacks of the surviving non-terminal events
in chronological order and finally executes the callback of the first terminal event (if provided).</p>
<p>In order to illustrate the use of terminal events, we will consider a damped pendulum with a small twist:
the friction coefficient <span class="math notranslate nohighlight">\(\alpha\)</span> switches discontinuously between 1 and 0 every time the angular
velocity <span class="math notranslate nohighlight">\(v\)</span> is zero. The ODE system reads:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{cases}
x^\prime = v \\
v^\prime = - 9.8\sin x - \alpha v
\end{cases},\end{split}\]</div>
<p>and the terminal event equation is, again, simply <span class="math notranslate nohighlight">\(v = 0\)</span>.</p>
<p>Let us begin with the definition of the terminal event:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Define a terminal event that turns air drag on/off</span>
<span class="w">    </span><span class="c1">// whenever the velocity goes to zero.</span>
<span class="w">    </span><span class="n">t_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t_ev</span><span class="p">(</span>
<span class="w">        </span><span class="c1">// The event equation.</span>
<span class="w">        </span><span class="n">v</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// The callback.</span>
<span class="w">        </span><span class="n">kw</span><span class="o">::</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ta</span><span class="p">,</span><span class="w"> </span><span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">mr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// NOTE: the value of the drag coefficient</span>
<span class="w">            </span><span class="c1">// is stored as the first (and only) runtime parameter</span>
<span class="w">            </span><span class="c1">// of the integrator.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ta</span><span class="p">.</span><span class="n">get_pars</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ta</span><span class="p">.</span><span class="n">get_pars_data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ta</span><span class="p">.</span><span class="n">get_pars_data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Do not stop the integration.</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">});</span>
</pre></div>
</div>
<p>Like in the case of non-terminal events, we specified as first construction argument
the event equation. As second argument we passed a callback function that will be invoked
when the event triggers.</p>
<p>As you can see from the code snippet, the callback signature for terminal events
differs from the signature non-terminal callbacks. Specifically:</p>
<ul class="simple">
<li><p>the event trigger time is not passed to the callback. This is not necessary
because, when a terminal event triggers, the state of the integrator is propagated
up to the event, and thus the trigger time is the current integrator time
(which can be fetched via <code class="docutils literal notranslate"><span class="pre">ta.get_time()</span></code>);</p></li>
<li><p>there is an additional boolean function argument, here called <code class="docutils literal notranslate"><span class="pre">mr</span></code>. We will be ignoring
this extra argument for the moment, its meaning will be clarified in the
<a class="reference internal" href="#tut-t-event-cooldown"><span class="std std-ref">cooldown section</span></a>;</p></li>
<li><p>whereas non-terminal event callbacks do not return anything, terminal event callbacks
are required to return <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>. If the callback returns <code class="docutils literal notranslate"><span class="pre">false</span></code> the integration
will always be stopped after the execution of the callback. Otherwise, when using the
<code class="docutils literal notranslate"><span class="pre">propagate_*()</span></code> family of functions, the integration will resume after the execution
of the callback.</p></li>
</ul>
<p>Note that, for the purpose of stopping the integration, an event <em>without</em> a callback is considered
equivalent to an event whose callback returns <code class="docutils literal notranslate"><span class="pre">false</span></code>.
We thus refer to terminal events without a callback or whose callback returns <code class="docutils literal notranslate"><span class="pre">false</span></code>
as <em>stopping</em> terminal events, because their occurrence will prevent the integrator from continuing
without user intervention.</p>
<p>Like for non-terminal events, the last callback argument is the sign of the time derivative
of the event equation at the event trigger time.</p>
<p>In this example, within the callback code we alter the value of the drag coefficient <span class="math notranslate nohighlight">\(\alpha\)</span>
(which is stored within the <a class="reference internal" href="tut_param.html#tut-param"><span class="std std-ref">runtime parameters</span></a> of the integrator): if <span class="math notranslate nohighlight">\(\alpha\)</span>
is currently 0, we set it to 1, otherwise we set it to 0.</p>
<p>Let us proceed to the construction of the integrator:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Construct the damped pendulum integrator.</span>
<span class="w">    </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span>
<span class="w">                                  </span><span class="c1">// NOTE: alpha is represented as</span>
<span class="w">                                  </span><span class="c1">// the first (and only) runtime</span>
<span class="w">                                  </span><span class="c1">// parameter: par[0].</span>
<span class="w">                                  </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">},</span>
<span class="w">                                 </span><span class="p">{</span><span class="mf">0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.025</span><span class="p">},</span>
<span class="w">                                 </span><span class="c1">// The list of terminal events.</span>
<span class="w">                                 </span><span class="n">kw</span><span class="o">::</span><span class="n">t_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">t_ev</span><span class="p">}};</span>
</pre></div>
</div>
<p>Similarly to the non-terminal events case, the list of terminal events
is specified when constructing an integrator via the <code class="docutils literal notranslate"><span class="pre">kw::t_events</span></code> keyword argument.</p>
<p>If a terminal event triggers within the single-step functions (<code class="docutils literal notranslate"><span class="pre">step()</span></code> and <code class="docutils literal notranslate"><span class="pre">step_backward()</span></code>),
the outcome of the integration will contain the index of the event that triggered. Let us see a simple example:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Propagate step-by-step until the event triggers.</span>
<span class="w">    </span><span class="n">taylor_outcome</span><span class="w"> </span><span class="n">oc</span><span class="p">;</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">oc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ta</span><span class="p">.</span><span class="n">step</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">oc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taylor_outcome</span><span class="o">::</span><span class="n">success</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print the outcome to screen.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Integration outcome: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oc</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event index        : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Integration outcome: taylor_outcome::terminal_event_0 (continuing)</span>
<span class="go">Event index        : 0</span>
</pre></div>
</div>
<p>The screen output confirms that the first (and only) event triggered. For stopping terminal events,
the numerical value of the outcome is the opposite of the event index minus one.</p>
<p>Because here we used the single step
function, even if the event’s callback returned <code class="docutils literal notranslate"><span class="pre">true</span></code> the integration was stopped in correspondence of the
event. Let us now use the <code class="docutils literal notranslate"><span class="pre">propagate_grid()</span></code> function instead, so that the integration resumes after the
execution of the callback:</p>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="w">    </span><span class="c1">// Integrate over a time grid.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mf">1.</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_grid</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">2.</span><span class="p">,</span><span class="w"> </span><span class="mf">3.</span><span class="p">,</span><span class="w"> </span><span class="mf">4.</span><span class="p">,</span><span class="w"> </span><span class="mf">5.</span><span class="p">,</span><span class="w"> </span><span class="mf">6.</span><span class="p">,</span><span class="w"> </span><span class="mf">7.</span><span class="p">,</span><span class="w"> </span><span class="mf">8.</span><span class="p">,</span><span class="w"> </span><span class="mf">9.</span><span class="p">,</span><span class="w"> </span><span class="mf">10.</span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Let&#39;s print the values of the state vector</span>
<span class="w">    </span><span class="c1">// over the time grid.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0u</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10u</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">)[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2u</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">)[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1u</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Final time: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ta</span><span class="p">.</span><span class="n">get_time</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">[-0.02976504606251412, -0.02063006479837935]</span>
<span class="go">[0.02970666582653454, 0.02099345736431702]</span>
<span class="go">[-0.01761378049610636, -0.01622382722426959]</span>
<span class="go">[0.01757771112979705, 0.01613903817360225]</span>
<span class="go">[-0.01037481471383597, -0.01205316233867281]</span>
<span class="go">[0.01035648925410416, 0.01177669636844242]</span>
<span class="go">[-0.006080605964468329, -0.008627473720971276]</span>
<span class="go">[0.006074559637531474, 0.008299135527482404]</span>
<span class="go">[-0.003544733998720797, -0.006013682818278612]</span>
<span class="go">[0.003546198899884463, 0.005703010459398463]</span>

<span class="go">Final time: 10</span>
</pre></div>
</div>
<p>The screen output confirms that indeed the integration continued up to the final time <span class="math notranslate nohighlight">\(t = 10\)</span>. The values
of the angle and angular velocity throughout the integration show how the drag coefficient (which was on roughly
for half of the total integration time) progressively slowed the bob down.</p>
<section id="cooldown">
<span id="tut-t-event-cooldown"></span><h3>Cooldown<a class="headerlink" href="#cooldown" title="Permalink to this heading">#</a></h3>
<p>One notable complication when restarting an integration that was stopped in correspondence of a terminal event
is the risk of immediately re-triggering the same event, which would lead to an endless loop without any progress
being made in the integration. This phenomenon is sometimes called <em>discontinuity sticking</em> in the literature.</p>
<p>In order to avoid this issue, whenever a terminal event occurs the event enters
a <em>cooldown</em> period. Within the cooldown period, occurrences of the same event are ignored by the event detection
system.</p>
<p>The length of the cooldown period is, by default, automatically deduced by heyoka, following a heuristic
that takes into account:</p>
<ul class="simple">
<li><p>the error tolerance of the integrator,</p></li>
<li><p>the derivative of the event equation at the trigger time.</p></li>
</ul>
<p>The heuristic works best under the assumption that the event function <span class="math notranslate nohighlight">\(g\left( t, \boldsymbol{x} \left( t \right) \right)\)</span>
does not change (much) after the execution of the event’s callback. If, for any reason, the automatic deduction heuristic is
to be avoided, it is possible to set a custom value for the cooldown.
A custom cooldown period can be selected when constructing
a terminal event via the <code class="docutils literal notranslate"><span class="pre">kw::cooldown</span></code> keyword argument.</p>
<p>When a terminal event triggers and enters the cooldown period, the event detection system will also try to detect
the occurrence of multiple roots of the event equation within the cooldown period. If such multiple roots are detected,
then the <code class="docutils literal notranslate"><span class="pre">mr</span></code> boolean parameter in the terminal event callback will be set to <code class="docutils literal notranslate"><span class="pre">true</span></code>, so that the user
has the possibility to handle such occurrence. Note that an <code class="docutils literal notranslate"><span class="pre">mr</span></code> value of <code class="docutils literal notranslate"><span class="pre">false</span></code> in the callback does not imply
that multiple roots do not exist, just that they were not detected.</p>
<p>Note that manually modifying the integrator’s time or state does <strong>not</strong> automatically reset the cooldown values
for terminal events. This could in principle lead to missing terminal events when the integration restarts.
For this reason, a member function called <code class="docutils literal notranslate"><span class="pre">reset_cooldowns()</span></code> is available to clear the cooldown timers of
all terminal events.</p>
</section>
</section>
<section id="limitations-and-caveats">
<h2>Limitations and caveats<a class="headerlink" href="#limitations-and-caveats" title="Permalink to this heading">#</a></h2>
<section id="badly-conditioned-event-equations">
<h3>Badly-conditioned event equations<a class="headerlink" href="#badly-conditioned-event-equations" title="Permalink to this heading">#</a></h3>
<p>Because heyoka’s event detection system is based on polynomial root finding techniques, it will experience
issues when the Taylor series of the event equations have roots of multiplicity greater than 1. This is usually
not a problem in practice, unless the event equations are written in such a way to always generate polynomials
with multiple roots.</p>
<p>For instance, an event equation such as</p>
<div class="math notranslate nohighlight">
\[\left[ g\left( t, \boldsymbol{x} \left( t \right) \right) \right]^2 = 0\]</div>
<p>will be troublesome, because both the event equation <em>and</em> its time derivative will be zero
when the event triggers. This will translate to a Taylor series with a double root in correspondence
of the event trigger time, which will lead to a breakdown of the root finding algorithm.
This, at best, will result in reduced performance and, at worst, in missing events altogether.
Additionally, in case of terminal events the automatically-deduced cooldown value in correspondence of
a double root will tend to infinity.</p>
<p>As a general rule, users should then avoid defining event equations in which the event trigger times
are stationary points.</p>
<p>Note that missed events due to badly-conditioned polynomials will likely be flagged by heyoka’s logging system.</p>
</section>
<section id="event-equations-and-timestepping">
<h3>Event equations and timestepping<a class="headerlink" href="#event-equations-and-timestepping" title="Permalink to this heading">#</a></h3>
<p>As explained earlier, the differential equations of the events are added to the ODE system and
integrated together with the original equations. Because of this, event equations influence the
selection of the adaptive timestep, even if no event is ever detected throughout the integration.</p>
<p>For instance, the absolute value of the event equation at the beginning of the timestep is taken
into account for the determination of the timestep size in relative error control mode. Thus, if
the typical magnitude of the event equation throughout the integration is much larger than the typical
magnitude of the state variables, the integration error for the state variables will increase with respect
to an integration without event detection.</p>
<p>As another example, an event equation which requires small timesteps for accurate numerical propagation
will inevitably slow down also the propagation of the ODEs.</p>
</section>
</section>
<section id="full-code-listing">
<h2>Full code listing<a class="headerlink" href="#full-code-listing" title="Permalink to this heading">#</a></h2>
<div class="highlight-c++ notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;heyoka/heyoka.hpp&gt;</span>

<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">heyoka</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// Create the symbolic variables x and v.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">make_vars</span><span class="p">(</span><span class="s">&quot;x&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;v&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Create a vector to store the times</span>
<span class="w">    </span><span class="c1">// at which v goes to zero.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Create the event object for the detection</span>
<span class="w">    </span><span class="c1">// of &#39;v == 0&#39;.</span>
<span class="w">    </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev</span><span class="p">(</span>
<span class="w">        </span><span class="c1">// The left-hand side of the event equation</span>
<span class="w">        </span><span class="n">v</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// The callback.</span>
<span class="w">        </span><span class="p">[</span><span class="o">&amp;</span><span class="n">zero_vel_times</span><span class="p">](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ta</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// Compute the state of the system when the</span>
<span class="w">            </span><span class="c1">// event triggered and print the value of x.</span>
<span class="w">            </span><span class="n">ta</span><span class="p">.</span><span class="n">update_d_output</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="w">            </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Value of x when v is zero: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ta</span><span class="p">.</span><span class="n">get_d_output</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>

<span class="w">            </span><span class="c1">// Add the event time to zero_vel_times.</span>
<span class="w">            </span><span class="n">zero_vel_times</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">time</span><span class="p">);</span>
<span class="w">        </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Create the integrator object</span>
<span class="w">    </span><span class="c1">// in double precision.</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{</span><span class="c1">// Definition of the ODE system:</span>
<span class="w">                                      </span><span class="c1">// x&#39; = v</span>
<span class="w">                                      </span><span class="c1">// v&#39; = -9.8 * sin(x)</span>
<span class="w">                                      </span><span class="p">{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span>
<span class="w">                                      </span><span class="c1">// Initial conditions</span>
<span class="w">                                      </span><span class="c1">// for x and v.</span>
<span class="w">                                      </span><span class="p">{</span><span class="mf">-0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">},</span>
<span class="w">                                      </span><span class="c1">// Non-terminal events.</span>
<span class="w">                                      </span><span class="n">kw</span><span class="o">::</span><span class="n">nt_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ev</span><span class="p">}};</span>

<span class="w">    </span><span class="c1">// Enable full precision printing.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">.</span><span class="n">precision</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Propagate for a few time units.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print the event times.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event detection time: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Redefine ev to detect only events</span>
<span class="w">    </span><span class="c1">// in the positive direction.</span>
<span class="w">    </span><span class="n">ev</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span>
<span class="w">        </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">zero_vel_times</span><span class="p">](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">time</span><span class="p">);</span><span class="w"> </span><span class="p">},</span>
<span class="w">        </span><span class="c1">// Specify the direction.</span>
<span class="w">        </span><span class="n">kw</span><span class="o">::</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">event_direction</span><span class="o">::</span><span class="n">positive</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Reset zero_vel_times and the integrator.</span>
<span class="w">    </span><span class="n">zero_vel_times</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="w">    </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">},</span><span class="w"> </span><span class="n">kw</span><span class="o">::</span><span class="n">nt_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ev</span><span class="p">}};</span>

<span class="w">    </span><span class="c1">// Propagate for a few time units.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print the event times.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">zero_vel_times</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event detection time: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// Define two close non-terminal events.</span>
<span class="w">    </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev0</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event 0 triggering at t=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">    </span><span class="n">nt_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">ev1</span><span class="p">(</span><span class="n">v</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">1e-12</span><span class="p">,</span><span class="w"> </span><span class="p">[](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">time</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event 1 triggering at t=&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">time</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Reset the integrator.</span>
<span class="w">    </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)},</span><span class="w"> </span><span class="p">{</span><span class="mf">-0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.</span><span class="p">},</span><span class="w"> </span><span class="n">kw</span><span class="o">::</span><span class="n">nt_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">ev0</span><span class="p">,</span><span class="w"> </span><span class="n">ev1</span><span class="p">}};</span>

<span class="w">    </span><span class="c1">// Propagate for a few time units.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Define a terminal event that turns air drag on/off</span>
<span class="w">    </span><span class="c1">// whenever the velocity goes to zero.</span>
<span class="w">    </span><span class="n">t_event</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="n">t_ev</span><span class="p">(</span>
<span class="w">        </span><span class="c1">// The event equation.</span>
<span class="w">        </span><span class="n">v</span><span class="p">,</span>
<span class="w">        </span><span class="c1">// The callback.</span>
<span class="w">        </span><span class="n">kw</span><span class="o">::</span><span class="n">callback</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[](</span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&amp;</span><span class="n">ta</span><span class="p">,</span><span class="w"> </span><span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">mr</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="c1">// NOTE: the value of the drag coefficient</span>
<span class="w">            </span><span class="c1">// is stored as the first (and only) runtime parameter</span>
<span class="w">            </span><span class="c1">// of the integrator.</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">ta</span><span class="p">.</span><span class="n">get_pars</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ta</span><span class="p">.</span><span class="n">get_pars_data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">ta</span><span class="p">.</span><span class="n">get_pars_data</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// Do not stop the integration.</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Construct the damped pendulum integrator.</span>
<span class="w">    </span><span class="n">ta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taylor_adaptive</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">{{</span><span class="n">prime</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">,</span>
<span class="w">                                  </span><span class="c1">// NOTE: alpha is represented as</span>
<span class="w">                                  </span><span class="c1">// the first (and only) runtime</span>
<span class="w">                                  </span><span class="c1">// parameter: par[0].</span>
<span class="w">                                  </span><span class="n">prime</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">-9.8</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">par</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">v</span><span class="p">},</span>
<span class="w">                                 </span><span class="p">{</span><span class="mf">0.05</span><span class="p">,</span><span class="w"> </span><span class="mf">0.025</span><span class="p">},</span>
<span class="w">                                 </span><span class="c1">// The list of terminal events.</span>
<span class="w">                                 </span><span class="n">kw</span><span class="o">::</span><span class="n">t_events</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="n">t_ev</span><span class="p">}};</span>

<span class="w">    </span><span class="c1">// Propagate step-by-step until the event triggers.</span>
<span class="w">    </span><span class="n">taylor_outcome</span><span class="w"> </span><span class="n">oc</span><span class="p">;</span>
<span class="w">    </span><span class="k">do</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">oc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ta</span><span class="p">.</span><span class="n">step</span><span class="p">());</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">oc</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">taylor_outcome</span><span class="o">::</span><span class="n">success</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Print the outcome to screen.</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Integration outcome: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">oc</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Event index        : &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">oc</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Integrate over a time grid.</span>
<span class="w">    </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_until</span><span class="p">(</span><span class="mf">1.</span><span class="p">);</span>
<span class="w">    </span><span class="k">auto</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ta</span><span class="p">.</span><span class="n">propagate_grid</span><span class="p">({</span><span class="mf">1.</span><span class="p">,</span><span class="w"> </span><span class="mf">2.</span><span class="p">,</span><span class="w"> </span><span class="mf">3.</span><span class="p">,</span><span class="w"> </span><span class="mf">4.</span><span class="p">,</span><span class="w"> </span><span class="mf">5.</span><span class="p">,</span><span class="w"> </span><span class="mf">6.</span><span class="p">,</span><span class="w"> </span><span class="mf">7.</span><span class="p">,</span><span class="w"> </span><span class="mf">8.</span><span class="p">,</span><span class="w"> </span><span class="mf">9.</span><span class="p">,</span><span class="w"> </span><span class="mf">10.</span><span class="p">});</span>

<span class="w">    </span><span class="c1">// Let&#39;s print the values of the state vector</span>
<span class="w">    </span><span class="c1">// over the time grid.</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0u</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10u</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;[&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">)[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2u</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;, &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">)[</span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2u</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1u</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Final time: &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">ta</span><span class="p">.</span><span class="n">get_time</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</section>
</section>


                </article>
              

              
              
              
              
                <footer class="prev-next-footer">
                  
<div class="prev-next-area">
    <a class="left-prev"
       href="tut_d_output.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Dense &amp; continuous output</p>
      </div>
    </a>
    <a class="right-next"
       href="advanced_tutorials.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Advanced tutorials</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div>
                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#non-terminal-events">Non-terminal events</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#event-direction">Event direction</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#multiple-events">Multiple events</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#terminal-events">Terminal events</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#cooldown">Cooldown</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#limitations-and-caveats">Limitations and caveats</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#badly-conditioned-event-equations">Badly-conditioned event equations</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#event-equations-and-timestepping">Event equations and timestepping</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#full-code-listing">Full code listing</a></li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Francesco Biscani, Dario Izzo
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      © Copyright 2020, 2021, 2022, 2023 Francesco Biscani, Dario Izzo.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/bootstrap.js?digest=5b4479735964841361fd"></script>
<script src="_static/scripts/pydata-sphinx-theme.js?digest=5b4479735964841361fd"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>